<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《Effective JavaScript编写高质量JavaSctipt代码的68个有效方法》读书笔记</title>
    <url>/2021/01/24/%E3%80%8AEffective%20JavaScript%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FJavaSctipt%E4%BB%A3%E7%A0%81%E7%9A%8468%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>《Effective JavaScript编写高质量JavaSctipt代码的68个有效方法》这本书中有关js的概念虽然有些已经有些过时了，但是知识点都还是比较准确的。坚持看下来后，还是对每个知识点做了整理，方便查阅。</p>
<a id="more"></a>

<h2 id="让自己习惯JavaSctipt"><a href="#让自己习惯JavaSctipt" class="headerlink" title="让自己习惯JavaSctipt"></a>让自己习惯JavaSctipt</h2><ul>
<li><p>1、<strong>了解你使用的JavaScript版本</strong></p>
<ul>
<li>决定你的应用程序支持JavaSctipt的那些版本。</li>
<li>确保你使用的任何JavaScript的特性对于应用程序将要运行的所有环境都是支持的。</li>
<li>总是在执行严格模式检查的环境中测试严格代码。</li>
<li>当心链接那些在不同严格模式下有不同预期的脚本。</li>
</ul>
</li>
<li><p>2、<strong>理解JavaScript的浮点数</strong></p>
<ul>
<li>JavaScript的数字都是双精度的浮点数。</li>
<li>JavaScript中的整数仅仅是双精度浮点数的一个子集，而不是一个单独的数据类型。</li>
<li>位运算符将数字视为32位的有符号整数。</li>
<li>当心浮点运算中的精度陷阱。</li>
</ul>
</li>
<li><p>3、<strong>当心隐式的强制转换</strong></p>
<ul>
<li><p>检测一个值是否为NaN：1、isNaN()；2、NaN是JavaScript中唯一不等于自身的值</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">a !== a <span class="comment">//也可以，但不太直观</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类型错误可能被隐式的强制转换所隐藏。</p>
</li>
<li><p>重载的运算符+是进行加法运算还是字符串连接操作取决于其参数的类型。</p>
</li>
<li><p>对象通过valueOf方法强制转换为数字，通过toString方法强制转换为字符串。</p>
</li>
<li><p>具有valueOf方法的对象应该实现toString方法，返回一个valueOf方法产生的数字的字符串表示。</p>
</li>
<li><p>测试一个值是否为未定义的值，应该使用typeof或者与undefined进行比较而不是使用真值运算。</p>
</li>
</ul>
</li>
<li><p>4、<strong>原始类型优于封装类型</strong></p>
<ul>
<li>当做相等比较时，原始类型的封装对象与其原始值行为不一样。</li>
<li>获取和设置原始类型的属性会隐式的创建封装对象。var s = new String(“hello”);</li>
</ul>
</li>
<li><p>5、<strong>避免对混合类型使用==运算符</strong></p>
<ul>
<li>当参数类型不同时，==运算符应用了一套难以理解的隐式转换规则。</li>
<li>使用===运算符，使读者不需要涉及任何的隐式强制转换就能明白你的比较运算。</li>
<li>当比较不同类型的值时，使用你自己的显式轻质转换是程序的行为更清晰。</li>
</ul>
</li>
<li><p>6、<strong>了解分号插入的局限</strong></p>
<ul>
<li>仅在“|”标记之前、一行的结束和程序的结束处推导分号。</li>
<li>仅在紧接着的标记不能被解析的时候推导分号。</li>
<li>在以( [ + - 或 / 字符开头的语句前绝不能省略分号。</li>
<li>当脚本连接的时候，在脚本之间显式的插入分号。</li>
<li>在return、throw、break、continue、++或- -的参数之前决不能换行。</li>
<li>分号不能作为for循环的头部或空语句的分隔符而被推导出。</li>
</ul>
</li>
<li><p>7、<strong>视字符串为16位的代码单元序列</strong></p>
<ul>
<li>JavaScript字符串由16位的代码单元组成，而不是由Unicode代码组成。</li>
<li>JavaScript使用两个代码单元表示2^16及其以上的Unicode代码点。这两个代码单元被称为代理对。</li>
<li>代理对甩开了字符串元素计数，length、charAt、charCodeAt方法以及正则表达式模式（例如“.”）受到了影响。</li>
<li>使用第三方的库编写可识别代码点的字符串操作。</li>
<li>每当你使用一个含有字符串操作的库时，你都需要查阅该库文档，看它如何处理代码点的整个范围。</li>
</ul>
</li>
</ul>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><ul>
<li>8、<strong>尽量少用全局对象</strong><ul>
<li>避免声明全局变量。</li>
<li>尽量声明局部变量。</li>
<li>避免对全局对象添加属性。</li>
<li>使用全局对象来做平台特性检测。</li>
</ul>
</li>
<li>9、<strong>始终声明局部变量</strong><ul>
<li>始终使用var声明新的局部变量。</li>
<li>考虑使用lint工具帮助检查未绑定的变量。</li>
</ul>
</li>
<li>10、<strong>避免使用with</strong><ul>
<li>避免使用with语句。</li>
<li>使用简短的变量名代替重复访问的对象。</li>
<li>显示地绑定局部变量到对象属性上，而不要使用with语句隐式的绑定它们。</li>
</ul>
</li>
<li>11、<strong>熟练掌握闭包</strong><ul>
<li>理解闭包的三个基本事实<ul>
<li>函数可以引用定义在其外部作用域的变量。</li>
<li>闭包比创建它们的函数有更长的生命周期。</li>
<li>闭包在内部存储其外部变量的引用，并能读写这些变量。</li>
</ul>
</li>
</ul>
</li>
<li>12、<strong>理解变量声明提升</strong><ul>
<li>在代码块中的变量声明会被隐式地提升到封闭函数的顶部。</li>
<li>重声明变量被视为单个变量。</li>
<li>考虑手动提升局部变量的声明，从而避免混淆。</li>
</ul>
</li>
<li>13、<strong>使用立即调用的函数表达式创建局部作用域</strong><ul>
<li>理解绑定与赋值的区别。</li>
<li>闭包通过引用而不是值捕获它们的外部变量。</li>
<li>使用立即调用的函数表达式（IIFE）来创建局部作用域。</li>
<li>当心在立即调用的函数表达式中包裹代码块可能改变起行为的情形。</li>
</ul>
</li>
<li>14、<strong>当心命名函数表达式笨拙的作用域</strong><ul>
<li>在Error对象的调试器中使用命名函数表达式改进栈跟踪。</li>
<li>在ES3和有问题的JavaScript环境中谨记函数表达式作用域会被Object.propertype污染。</li>
<li>谨记在错误百出的JavaScript环境中会提升命名函数表达式声明，并导致命名函数表达式的重复存储。</li>
<li>考虑避免使用命名函数表达式或在发布前删除函数名。</li>
<li>如果你将代码发布到正确实现的ES5环境中，那么你没有什么好担心的。</li>
</ul>
</li>
<li>15、<strong>当心局部块函数声明笨拙的作用域</strong><ul>
<li>始终将函数声明置于程序或被包含的函数的最外层以避免不可移植的行为。</li>
<li>使用var声明和有条件的赋值语句替代有条件的函数声明。</li>
</ul>
</li>
<li>16、<strong>避免使用eval创建局部变量</strong><ul>
<li>避免使用eval函数创建的变量污染调用者的作用域。</li>
<li>如果eval函数代码可能创建全局变量，将此调用封装到嵌套的函数中以防止作用域污染。</li>
</ul>
</li>
<li>17、<strong>间接调用eval函数优于直接调用</strong><ul>
<li>将eval函数同一个毫无意义的字面量包裹在序列表达式中以达到强制使用间接调用eval函数的目的。</li>
<li>尽可能间接调用eval函数，而不要直接调用eval函数。</li>
</ul>
</li>
</ul>
<h2 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h2><ul>
<li>18、<strong>理解函数调用、方法调用及构造函数调用之间的不同</strong><ul>
<li>方法调用将被查找方法属性的对象作为调用接收者。</li>
<li>函数调用将全局变量（处于严格模式下则为undefined）作为其接收者。一般很少使用函数调用语法来调用方法。</li>
<li>构造函数需要通过new运算符调用，并产生一个新的对象作为其接收者。</li>
</ul>
</li>
<li>19、<strong>熟练掌握高阶函数</strong><ul>
<li>高阶函数是那些将函数作为参数或返回值的函数。</li>
<li>熟悉掌握现有库中的高阶函数。</li>
<li>学会发现可以被高阶函数所取代的常见的编码模式。</li>
<li>高阶函数可以是代码更简洁、更高效、更可读。</li>
</ul>
</li>
<li>20、<strong>使用call方法自定义接收者来调用方法</strong><ul>
<li>使用call方法自定义接收者来调用函数。</li>
<li>使用call方法可以调用在给定的对象中不存在的方法。</li>
<li>使用call方法定义高阶函数允许使用者给回调函数制定接收者。</li>
</ul>
</li>
<li>21、<strong>使用apply方法通过不同数量的参数调用函数</strong><ul>
<li>使用apply方法制定一个可计算的参数数组来调用可变参数的函数。</li>
<li>使用apply方法的第一个参数给可变参数的方法提供一个接收者。</li>
</ul>
</li>
<li>22、<strong>使用arguments创建可变参数的函数</strong><ul>
<li>使用隐式的arguments对象实现可变参数的函数。</li>
<li>考虑对可变参数提供一个额外的固定元数的版本，从而使使用者无需借助apply方法。</li>
</ul>
</li>
<li>23、<strong>永远不要修改arguments对象</strong><ul>
<li>永远不要修改arguments对象。</li>
<li>使用[].slice.call(arguments)将arguments对象复制到一个整整的数组中在进行修改。</li>
</ul>
</li>
<li>24、<strong>使用变量保存argumens的引用</strong><ul>
<li>当引用arguments时当心函数嵌套层级。</li>
<li>绑定一个明确作用域的引用到argumen是变量，从而可以在嵌套的函数中引用它。</li>
</ul>
</li>
<li>25、<strong>使用bind方法提取具有确定接收者的方法</strong><ul>
<li>要注意提取一个方法不会将方法的接收者绑定到该方法的对象上。</li>
<li>当给高阶函数传递对象方法时，使用匿名函数在适当的接收者上调用该方法。</li>
<li>使用bind方法创建绑定到适当接收者的函数。</li>
</ul>
</li>
<li>26、<strong>使用bind方法实现函数柯里化</strong><ul>
<li>使用bind方法实现函数柯里化，即创建一个固定需求参数子集的委托函数。</li>
<li>传入null或undefined作为接收者的参数来实现函数柯里化，从而忽略其接收者。</li>
</ul>
</li>
<li>27、<strong>使用闭包而不是字符串来封装代码</strong><ul>
<li>当将字符串传递给eval函数以执行它们的API时，绝不要在字符串中包含局部变量的引用。</li>
<li>接受函数调用的API优于使用eval函数执行字符串的API。</li>
</ul>
</li>
<li>28、<strong>不要信赖函数对象的toString方法</strong><ul>
<li>当调用函数的toString方法时，并没有要求JavaScript引擎能够精确地获取到函数的源代码。</li>
<li>由于在不同的引擎下调用toString方法的结果可能不同，所以绝不要信赖函数源代码的详细细节。</li>
<li>toString方法的执行结果并不会暴露存储在闭包中的局部变量值。</li>
<li>通常情况下，应该避免使用函数对象的toString方法。</li>
</ul>
</li>
<li>29、<strong>避免使用非标准的栈检查属性</strong><ul>
<li>避免使用非标准的arguments.caller和argumens.callee属性，因为它们不具备良好的移植性。</li>
<li>避免使用非标准的函数对象caller属性，因为在包含全部栈信息方面，它是不可靠的。</li>
</ul>
</li>
</ul>
<h2 id="对象和原型"><a href="#对象和原型" class="headerlink" title="对象和原型"></a>对象和原型</h2><ul>
<li>30、<strong>理解prototype、getPrototypeOf和<strong>proto</strong>之间的不同</strong><ul>
<li>C.prototype属性是new C()创建的对象的原型。</li>
<li>Object.getPrototypeOf(obj)是ES5中检索对象原型的标准函数。</li>
<li>obj.<strong>proto</strong>是检索对象原型的非标准方法。</li>
<li>类是由一个构造函数和一个关联的原型组成的一种设计模式。</li>
</ul>
</li>
<li>31、<strong>使用Object.getPrototypeOf函数而不要使用<strong>proto</strong>属性</strong><ul>
<li>使用符合标准的Object.getPrototypeOf函数而不要使用非标准的<strong>proto</strong>属性。</li>
<li>在支持<strong>proto</strong>属性的非ES5环境中实现Object.getPrototypeOf函数。</li>
</ul>
</li>
<li>32、<strong>始终不要修改<strong>proto</strong>属性</strong><ul>
<li>始终不要修改对象的<strong>proto</strong>属性。</li>
<li>使用Object.create函数给新对象设置自定义的原型。</li>
</ul>
</li>
<li>33、<strong>使构造函数与new操作符无关</strong><ul>
<li>通过使用new操作符或Object.create方法在构造函数定义中调用自身使得该构造函数与调用语法无关。</li>
<li>当一个函数使用new操作符调用时，清晰地文档化该函数。</li>
</ul>
</li>
<li>34、<strong>在原型中存储方法</strong><ul>
<li>将方法存储在实例对象中将创建该函数的多个副本，因为每个实例对象都有一份副本。</li>
<li>将方法存储于原型中优于存储在实例对象中。</li>
</ul>
</li>
<li>35、<strong>使用闭包存储私有数据</strong><ul>
<li>闭包变量是私有的，只能通过局部的引用获取。</li>
<li>将局部变量作为私有数据从而通过方法实现信息隐藏。</li>
</ul>
</li>
<li>36、<strong>只将实例状态存储在实例对象中</strong><ul>
<li>共享可变数据可能会出问题，因为原型是被其所有的实例共享的。</li>
<li>将可变的实例状态存储在实例对象中。</li>
</ul>
</li>
<li>37、<strong>认识到this变量的隐式绑定问题</strong><ul>
<li>this变量的作用域总是由其最近的封闭函数所确定。</li>
<li>使用一个局部变量（通常命名为self、me或that）使得this绑定对于内部函数是可用的。</li>
</ul>
</li>
<li>38、<strong>在子类的构造函数中调用父类的构造函数</strong><ul>
<li>在子类构造函数中显式地传入this作为显式的接收者调用父类构造函数。</li>
<li>使用Object.create函数来构造子类的原型对象以避免调用父类的构造函数。</li>
</ul>
</li>
<li>39、<strong>不要重用父类的属性名</strong><ul>
<li>留意父类使用的所有属性名。</li>
<li>不要在子类中重用父类的属性名。</li>
</ul>
</li>
<li>40、<strong>避免继承标准类</strong><ul>
<li>继承标准类往往会由于一些特殊的内部属性（如[[Class]]）而被破坏。</li>
<li>使用属性委托优于继承标准类。</li>
</ul>
</li>
<li>41、<strong>将原型视为实现细节</strong><ul>
<li>对象是接口，原型是实现。</li>
<li>避免检查你无法控制的对象的原型结构。</li>
<li>避免检查实现在你无法控制的对象内部的属性。</li>
</ul>
</li>
<li>42、<strong>避免使用轻率的猴子补丁</strong><ul>
<li>由于对象共享原型，因此每一个对象都可以增加、删除或修改原型的属性。这个有争议的实践，通常被称为猴子补丁（monkey-patching）</li>
<li>避免使用轻率的猴子补丁。</li>
<li>记录程序库所执行的所有猴子补丁。</li>
<li>考虑通过将修改置于一个导出函数中，使猴子补丁成为可选的。</li>
<li>使用猴子补丁为缺失的标准API提供polyfills。</li>
</ul>
</li>
</ul>
<h2 id="数组和字典"><a href="#数组和字典" class="headerlink" title="数组和字典"></a>数组和字典</h2><ul>
<li>43、<strong>使用Object的直接实例构造轻量级的字典</strong><ul>
<li>使用对象字面量构建轻量级字典。</li>
<li>轻量级字典应该是Object.prototype的直接子类，以使for…in循环免受原型污染。</li>
</ul>
</li>
<li>44、<strong>使用null原型以防止原型污染</strong><ul>
<li>在ES5环境中，使用Object.create(null)创建的自由原型的空对象是不太容易被污染的。</li>
<li>在一些较老的环境中，考虑使用{<strong>proto</strong>: null}。</li>
<li>但要注意<strong>proto</strong>既不标准，也不是完全可移植的，并且可能会在未来的JavaScript环境中去除。</li>
<li>绝不要使用“<strong>proto</strong>”名作为字典中的key，因为一些环境将其作为特殊的属性对待。</li>
</ul>
</li>
<li>45、<strong>使用hasOwnProperty方法以避免原型污染</strong><ul>
<li>使用hasOwnProperty方法避免原型污染。</li>
<li>使用词法作用域和call方法避免覆盖hasOwnProperty方法。</li>
<li>考虑在封装hasOwnProperty测试样板代码的类中实现字典操作。</li>
<li>使用字典类避免将“<strong>proto</strong>”作为key来使用。</li>
</ul>
</li>
<li>46、<strong>使用数组而不要使用字典来存储有序集合</strong><ul>
<li>使用for…in循环来枚举对象属性应当与顺序无关。</li>
<li>如果聚集运算字典中的数据，确保聚集操作与顺序无关。</li>
<li>使用数组而不是字典来存储有序集合。</li>
</ul>
</li>
<li>47、<strong>绝不要在Object.prototype中增加可枚举的属性</strong><ul>
<li>避免在Object.prototype中增加属性。</li>
<li>考虑编写一个函数代替Object.prototype方法。</li>
<li>如果你确实需要在Object.prototype中增加属性，请使用ES5中的Object.defineProperty方法将它们定义为不可枚举的属性。</li>
</ul>
</li>
<li>48、<strong>避免在枚举期间修改对象</strong><ul>
<li>当使用for…in循环枚举一个对象的属性时，确保不要修改该对象。</li>
<li>当迭代一个对象时，如果该对象的内容可能会在循环期间被改变，应该使用while循环或经典的for循环来代替for…in循环。</li>
<li>为了在不断变化的数据结构中能够预测枚举，考虑使用一个有序的数据结构，例如数组，而不要使用字典对象。</li>
</ul>
</li>
<li>49、<strong>数组迭代要优先使用for循环而不是for…in循环</strong><ul>
<li>迭代数组的索引属性应当总是使用for循环而不是for…in循环。</li>
<li>考虑在循环之前将数组的长度存储在一个局部变量中以避免重新计算数组长度。</li>
</ul>
</li>
<li>50、<strong>迭代方法优于循环</strong><ul>
<li>使用迭代方法（如Array.prototype.forEach和Array.prototype.map）替换for循环使得代码更可读，并且避免了重复循环控制逻辑。</li>
<li>使用自定义的迭代函数来抽象未被标准库支持的常见循环模式。</li>
<li>在需要提前终止循环的情况下，仍然推荐使用传统的循环。另外，some和every方法也可用于提前退出。</li>
</ul>
</li>
<li>51、<strong>在类数组对象上复用通用的数组方法</strong><ul>
<li>对于类数组对象，通过提取方法对象并使用其call方法来复用通用的Array方法。</li>
<li>任意一个具有索引属性和恰当length属性的对象都可以使用通用的Array方法。</li>
</ul>
</li>
<li>52、<strong>数组字面量优于数组构造函数</strong><ul>
<li>如果数组构造函数的第一个参数是数字则数组的构造函数行为是不同的。</li>
<li>使用数组字面量替代数组构造函数。</li>
</ul>
</li>
</ul>
<h2 id="库和API设计"><a href="#库和API设计" class="headerlink" title="库和API设计"></a>库和API设计</h2><ul>
<li>53、<strong>保持一致的约定</strong><ul>
<li>在变量命名和函数签名中使用一致的约定。</li>
<li>不要偏离用户在他们的开发平台中很可能遇到的约定。</li>
</ul>
</li>
<li>54、<strong>将undefined看作“没有值”</strong><ul>
<li>避免使用undefined表示任何非特定值。</li>
<li>使用描述性的字符串值或命名布尔属性的对象，而不要使用undefined或null来代表特定应用标志。</li>
<li>提供参数默认值应当采用测试undefined的方式，而不是检查arguments.length。</li>
<li>在允许0、NaN或空字符串为有效参数的地方，绝不要通过真值测试来实现参数默认值。</li>
</ul>
</li>
<li>55、<strong>接收关键字参数的选项对象</strong><ul>
<li>使用选项对象使得API更具可读性、更容易记忆。</li>
<li>所有通过选项对象提供的参数应当被视为可选的。</li>
<li>使用extend函数抽象出从选项对象中提取值的逻辑。</li>
</ul>
</li>
<li>56、<strong>避免不必要的状态</strong><ul>
<li>尽可能地使用无状态的API。</li>
<li>如果API是有状态的，标示出每个操作与哪些状态有关联。</li>
</ul>
</li>
<li>57、<strong>使用结构类型设计灵活的接口</strong><ul>
<li>使用结构类型（也称为鸭子类型）来设计灵活的对象接口。</li>
<li>结构接口更灵活、更轻量，所以应该避免使用继承。</li>
<li>针对单元测试，使用mock对象即接口的替代实现来提供可复验的行为。</li>
</ul>
</li>
<li>58、<strong>区分数组对象和类数组对象</strong><ul>
<li>绝不重载与其他类型由重叠的结构类型。</li>
<li>当重载一个结构类型与其他类型时，先测试其他类型。</li>
<li>当重载其他对象类型时，接收真数组而不是类数组对象。</li>
<li>文档标注你的API是否接收真数组或类数组值。</li>
<li>使用ES5提供的Array.isArray方法测试真数组。</li>
</ul>
</li>
<li>59、<strong>避免过度的强制转换</strong><ul>
<li>避免强制转换和重载的混用。</li>
<li>考虑防御性地监视非预期的输入。</li>
</ul>
</li>
<li>60、<strong>支持方法链</strong><ul>
<li>使用方法链来链接无状态的操作。</li>
<li>通过在无状态的方法中返回新对象来支持方法链。</li>
<li>通过在有状态的方法中返回this来支持方法链。</li>
</ul>
</li>
</ul>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul>
<li>61、<strong>不要阻塞I/O事件队列</strong><ul>
<li>异步API使用回调函数来延缓处理代价高昂的操作以避免阻塞主应用程序。</li>
<li>JavaScript并发地接收事件，但会使用一个事件队列按序地处理事件处理程序。</li>
<li>在应用程序事件队列中绝不要使用阻塞的I/O。</li>
</ul>
</li>
<li>62、<strong>在异步序列中使用嵌套或命名的回调函数</strong><ul>
<li>减少过多嵌套的方法之一是将嵌套的回调函数作为命名的函数，并将它们需要的附加数据作为额外的参数传递。</li>
<li>使用嵌套或命名的回调函数按顺序地执行多个异步操作。</li>
<li>尝试在过多的嵌套的回调函数和尴尬的命名的非嵌套回调函数之间取得平衡。</li>
<li>避免将可能并行执行的操作顺序化。</li>
</ul>
</li>
<li>63、<strong>当心丢弃错误</strong><ul>
<li>通过编写共享的错误处理函数来避免复制和粘贴错误处理代码。</li>
<li>确保明确地处理所有的错误条件以避免丢弃错误。</li>
</ul>
</li>
<li>64、<strong>对异步循环使用递归</strong><ul>
<li>循环是不能异步的。</li>
<li>使用递归函数在事件循环的单独轮次中执行迭代。</li>
<li>在事件循环的单独轮次中执行递归，并不会导致调用栈溢出。</li>
</ul>
</li>
<li>65、<strong>不要在计算时阻塞事件队列</strong><ul>
<li>避免在主事件队列中执行代价高昂的算法。</li>
<li>在支持Worker API的平台，该API可以用来在一个独立的事件队列中运行长计算的程序。</li>
<li>在Worker API不可用或代价昂贵的环境中，考虑将计算程序分解到事件循环的多个轮次中。</li>
</ul>
</li>
<li>66、<strong>使用计数器来执行并行操作</strong><ul>
<li>当一个应用程序依赖于特定的事件顺序才能正常工作时，这个程序会遭受数据竞争。</li>
<li>JavaScript应用程序中的事件发生是不确定的，即顺序是不可预测的。</li>
<li>使用计数器避免并行操作中的数据竞争。</li>
</ul>
</li>
<li>67、<strong>绝不要同步地调用异步的回调函数</strong><ul>
<li>即使可以立即得到数据，也绝不要同步地调用异步回调函数。</li>
<li>同步地调用异步的回调函数扰乱了预期的操作序列，并可能导致意想不到的交错代码。</li>
<li>同步地调用异步的回调函数可能导致栈溢出或错误地处理异常。</li>
<li>使用异步的API，比如setTimeout函数来调度异步回调函数，使其运行与另一个回合。</li>
</ul>
</li>
<li>68、<strong>使用promise模式清洁异步逻辑</strong><ul>
<li>promise代表最终值，即并行操作完成时最终产生的结果。</li>
<li>使用promise组合不同的并行操作。</li>
<li>使用promise模式的API避免数据竞争。</li>
<li>在要求有意的竞争条件时使用select（也被称为choose）。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS盒模型</title>
    <url>/2021/01/24/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h5 id="CSS盒模型，可以认为每个html标签都是一个方块，然后这个方块又包着几个小方块，如同盒子一层层的包裹着。"><a href="#CSS盒模型，可以认为每个html标签都是一个方块，然后这个方块又包着几个小方块，如同盒子一层层的包裹着。" class="headerlink" title="CSS盒模型，可以认为每个html标签都是一个方块，然后这个方块又包着几个小方块，如同盒子一层层的包裹着。"></a>CSS盒模型，可以认为每个html标签都是一个方块，然后这个方块又包着几个小方块，如同盒子一层层的包裹着。</h5><blockquote>
<p>“every element in web design is a rectangular box”</p>
</blockquote>
<a id="more"></a>

<h5 id="盒模型包括：内容-content-、内边距-padding-、外边距-margin-、边框-border-。"><a href="#盒模型包括：内容-content-、内边距-padding-、外边距-margin-、边框-border-。" class="headerlink" title="盒模型包括：内容(content) 、内边距(padding)、外边距(margin)、边框(border)。"></a>盒模型包括：内容(content) 、内边距(padding)、外边距(margin)、边框(border)。</h5><p><img src="https://user-gold-cdn.xitu.io/2017/10/25/9cb491d4bd5d326aeb16632280411283?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h5 id="盒模型主要分为两种：标准盒模型-box-sizing-content-box-、IE盒模型-box-sizing-border-box"><a href="#盒模型主要分为两种：标准盒模型-box-sizing-content-box-、IE盒模型-box-sizing-border-box" class="headerlink" title="盒模型主要分为两种：标准盒模型(box-sizing: content-box;)、IE盒模型(box-sizing: border-box)"></a>盒模型主要分为两种：标准盒模型(box-sizing: content-box;)、IE盒模型(box-sizing: border-box)</h5><h5 id="CSS3新增了一种类型：box-sizing-padding-box"><a href="#CSS3新增了一种类型：box-sizing-padding-box" class="headerlink" title="CSS3新增了一种类型：box-sizing: padding-box;"></a>CSS3新增了一种类型：box-sizing: padding-box;</h5><h2 id="盒模型的区别"><a href="#盒模型的区别" class="headerlink" title="盒模型的区别"></a>盒模型的区别</h2><h5 id="标准盒模型content-box（默认）"><a href="#标准盒模型content-box（默认）" class="headerlink" title="标准盒模型content-box（默认）"></a>标准盒模型content-box（默认）</h5><p>布局所占宽度Width：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Width &#x3D; width + padding-left + padding-right + border-left + border-right</span><br></pre></td></tr></table></figure>

<p>布局所占高度Height:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Height &#x3D; height + padding-top + padding-bottom + border-top + border-bottom</span><br></pre></td></tr></table></figure>

<h5 id="IE盒模型border-box"><a href="#IE盒模型border-box" class="headerlink" title="IE盒模型border-box"></a>IE盒模型border-box</h5><p>布局所占宽度Width：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Width &#x3D; width(包含padding-left + padding-right + border-left + border-right)</span><br></pre></td></tr></table></figure>

<p>布局所占高度Height:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Height &#x3D; height(包含padding-top + padding-bottom + border-top + border-bottom)</span><br></pre></td></tr></table></figure>

<h5 id="padding-box"><a href="#padding-box" class="headerlink" title="padding-box"></a>padding-box</h5><p>布局所占宽度Width：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Width &#x3D; width(包含padding-left + padding-right) + border-top + border-bottom</span><br></pre></td></tr></table></figure>

<p>布局所占高度Height:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Height &#x3D; height(包含padding-top + padding-bottom) + border-top + border-bottom</span><br></pre></td></tr></table></figure>

<h5 id="注意：宽度是不包括margin的"><a href="#注意：宽度是不包括margin的" class="headerlink" title="注意：宽度是不包括margin的"></a>注意：宽度是不包括margin的</h5><h2 id="盒模型使用"><a href="#盒模型使用" class="headerlink" title="盒模型使用"></a>盒模型使用</h2><h5 id="我们在编写页面代码时应尽量使用标准盒模型，需要在页面第一行声明DOCTYPE文档类型，就会默认使用标准盒模型了。若不声明DOCTYPE类型，IE浏览器会将盒子模型解释为IE盒子模型。"><a href="#我们在编写页面代码时应尽量使用标准盒模型，需要在页面第一行声明DOCTYPE文档类型，就会默认使用标准盒模型了。若不声明DOCTYPE类型，IE浏览器会将盒子模型解释为IE盒子模型。" class="headerlink" title="我们在编写页面代码时应尽量使用标准盒模型，需要在页面第一行声明DOCTYPE文档类型，就会默认使用标准盒模型了。若不声明DOCTYPE类型，IE浏览器会将盒子模型解释为IE盒子模型。"></a>我们在编写页面代码时应尽量使用标准盒模型，需要在页面第一行声明DOCTYPE文档类型，就会默认使用标准盒模型了。若不声明DOCTYPE类型，IE浏览器会将盒子模型解释为IE盒子模型。</h5><h2 id="margin叠加"><a href="#margin叠加" class="headerlink" title="margin叠加"></a>margin叠加</h2><p>外边距叠加是一个相当简单的概念。 但是，在实践中对网页进行布局时， 它会造成许多混淆。 简单的说， 当两个或更多个垂直边距相遇时， 它们将形成一个外边距。这个外边距的高度等于两个发生叠加的外边距的高度中的较大者。但是注意只有普通文档流中块框的垂直外边距才会发生外边距叠加。 行内框、 浮动框或绝对定位框之间的外边距不会叠加。</p>
<p>一般来说， 垂直外边距叠加有三种情况：</p>
<ul>
<li>元素自身叠加 当元素没有内容（即空元素）、内边距、边框时， 它的上下边距就相遇了， 即会产生叠加（垂直方向）。 当为元素添加内容、 内边距、 边框任何一项， 就会取消叠加。</li>
<li>相邻元素叠加 相邻的两个元素， 如果它们的上下边距相遇，即会产生叠加。</li>
<li>包含（父子）元素叠加 包含元素的外边距隔着 父元素的内边距和边框， 当这两项都不存在的时候， 父子元素垂直外边距相邻， 产生叠加。 添加任何一项即会取消叠加。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://juejin.im/post/59ef72f5f265da4320026f76" target="_blank" rel="noopener">CSS盒模型详解</a></li>
<li><a href="https://adamschwartz.co/magic-of-css/chapters/1-the-box/" target="_blank" rel="noopener">CSS Magic: The Box</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>理解闭包——你只要学会三个基本事实</title>
    <url>/2021/01/24/%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85%E2%80%94%E2%80%94%E4%BD%A0%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%BC%9A%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E4%BA%8B%E5%AE%9E/</url>
    <content><![CDATA[<p>学习JavaScript的小伙伴一定都听说过闭包这个概念，但是真正你真的理解闭包了吗？理解闭包其实没有那么困难，只需要学会三个基本的事实。</p>
<a id="more"></a>

<h4 id="事实1-javascript允许你引用在当前函数以外定义的变量"><a href="#事实1-javascript允许你引用在当前函数以外定义的变量" class="headerlink" title="事实1 javascript允许你引用在当前函数以外定义的变量"></a>事实1 javascript允许你引用在当前函数以外定义的变量</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeSandwich</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> magicIngredient = <span class="string">"peanut butter"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">filling</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> magicIngredient + <span class="string">" and "</span> + filling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> make(<span class="string">"jelly"</span>);</span><br><span class="line">&#125;</span><br><span class="line">makeSandwich();  <span class="comment">// "peanut butter and jelly"</span></span><br></pre></td></tr></table></figure>

<p>请注意内部的make函数式如何引用在外部makeSanwich函数内的magicIngredient变量的。</p>
<h4 id="事实2-即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量"><a href="#事实2-即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量" class="headerlink" title="事实2 即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量"></a>事实2 即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量</h4><p>这个事实意味着，你可以返回一个内部函数，并在稍后调用它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sandwichMaker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> magicIngredient = <span class="string">"peanut butter"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">filling</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> magicIngredient + <span class="string">" and "</span> + filling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> make;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = sandwichMaker();</span><br><span class="line">f(<span class="string">"jelly"</span>);  <span class="comment">// "peanut butter and jelly"</span></span><br><span class="line">f(<span class="string">"bananas"</span>);  <span class="comment">// "peanut butter and bananas"</span></span><br><span class="line">f(<span class="string">"marshmallows"</span>);  <span class="comment">// "peanut butter and marshmallows"</span></span><br></pre></td></tr></table></figure>

<p>调用f实际上是调用make函数。即使sandwichMaker函数已经返回，make函数仍能记住magicIngredient的值。</p>
<p>因为：javascript的函数值包含了比调用它们时执行所需要的代码还要多的信息。而且，javascript函数值还在内部存储它们可能会引用的定义在其封闭作用域的变量。那些在其所涵盖的作用域内的跟踪变量的函数被称为闭包。</p>
<p>make函数就是一个闭包，引用了两个内部变量：magicIngredient和filling。</p>
<p>我们可以使用函数表达式编写一个更通用的sandwichMaker函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sandwichMaker</span>(<span class="params">magicIngredient</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">filling</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> magicIngredient + <span class="string">"and"</span> + filling;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="事实3-闭包可以更新外部变量的值"><a href="#事实3-闭包可以更新外部变量的值" class="headerlink" title="事实3 闭包可以更新外部变量的值"></a>事实3 闭包可以更新外部变量的值</h4><p>实际上，闭包存储的是外部变量的引用，而不是它们的值的副本。因此，对于任何具有访问这些外部变量的闭包，都可以进行更新。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> val = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">set</span>: function(newValu) &#123; val = newVal; &#125;,</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;<span class="keyword">return</span> val;&#125;,</span><br><span class="line">        type: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> typeOf val;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = box();</span><br><span class="line">b.type();  <span class="comment">// "undefined"</span></span><br><span class="line">b.set(<span class="number">98.6</span>);</span><br><span class="line">b.get();  <span class="comment">// 98.6</span></span><br><span class="line">b.type(); <span class="comment">// "number"</span></span><br></pre></td></tr></table></figure>

<h4 id="总结时刻"><a href="#总结时刻" class="headerlink" title="总结时刻"></a>总结时刻</h4><ul>
<li>函数可以引用定义在其外部作用域的变量</li>
<li>闭包比创建它们的函数有更长的生命周期</li>
<li>闭包在内部存储其外部变量的引用，并能读写这些变量</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>批判性思维工具与费曼学习法实践</title>
    <url>/2019/11/24/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>回忆我漫长的学生时代(<del>其实也并不漫长</del>)，学习成绩最高光时刻好像感觉自己并没有比别人多努力成绩就自然地进步了<del>我真是不怕被打</del>。后来想想可能那时候自己无意间使用了一种高效又适合自己的学习方法。</p>
<p>本文尝试结合现阶段的学习过程总结一下现在使用的学习方法。希望也能帮助自己理清思路，更有效的利用时间来充实自己。嘻嘻。</p>
<a id="more"></a>

<h1 id="怎样才算真正拥有了知识？"><a href="#怎样才算真正拥有了知识？" class="headerlink" title="怎样才算真正拥有了知识？"></a>怎样才算真正拥有了知识？</h1><blockquote>
<p>在斋藤孝的《学会学习》一书中，把学习过程拆解成了三个部分：<strong>输入、处理和输出。</strong></p>
<p><strong>输入的重点是把知识理解透彻；处理是把知识内化成自己的本领；输出是为了检验学习成果。</strong></p>
</blockquote>
<p>但实际情况下，在学习过程中还有一个灭霸级对手在阻挠我们拥有知识，那就是<strong>遗忘</strong>。</p>
<h1 id="为什么学过的知识总是记不住？"><a href="#为什么学过的知识总是记不住？" class="headerlink" title="为什么学过的知识总是记不住？"></a>为什么学过的知识总是记不住？</h1><p>我们平时的记忆过程是：输入的信息在经过人的注意过程的学习后，便成为了人的短时的记忆，再经过进一步强化后成为长时记忆。如果根据艾宾浩斯遗忘曲线的理论，我们学习的知识会按照一定时间规律被部分遗忘。</p>
<p><strong>根据艾宾浩斯遗忘曲线得到的结果：</strong></p>
<p>20分后，42%被遗忘掉，58%被记住。</p>
<p>1小时后，56%被遗忘掉，44%被记住。</p>
<p>1天后，74%被遗忘掉，26%被记住。</p>
<p>1周后，77%被遗忘掉，23%被记住。</p>
<p>1个月后，79%被遗忘掉，21%被记住。</p>
<p><img src="https://wiki.mbalib.com/w/images/0/02/%E8%89%BE%E5%AE%BE%E6%B5%A9%E6%96%AF%E8%AE%B0%E5%BF%86%E9%81%97%E5%BF%98%E6%9B%B2%E7%BA%BF.jpg" alt="艾宾浩斯遗忘曲线"></p>
<p>如果按照这样的速度遗忘的话，现在正在学习的我会有多焦虑。想想我正在读的文字，一个月以后可能就彻底从我脑海里消失了。所以，我们需要定期复习自已学习的知识来对抗遗忘曲线，让知识成为我们的长期记忆。</p>
<p>复习当然不能花费我们太多时间。复习时如果没有使用有效的方法，而只是掏出书本或者笔记再看一遍的话，与学习新知识的时间差不多，那么真是效率极低的复习方式。</p>
<p>接下来我们在输入阶段和输出阶段尝试一种新的学习思路。</p>
<h1 id="新知——输入阶段"><a href="#新知——输入阶段" class="headerlink" title="新知——输入阶段"></a>新知——输入阶段</h1><p>刚才提到学习过程的三大阶段，<strong>输入、处理和输出</strong>。我们主要来探究一下输入阶段。</p>
<p>带着好奇心和对新知识的渴望，我们打开了一本书、讲义或者一篇博文(<del>反正就是你要学的东西</del>)开始将作者的文字一行一行读下来。或许还有个记笔记的好习惯？那么就开始了文章重点的“摘抄”，笔记内容的快速填充，俗称“抄书”。</p>
<p>这样一套操作下来，刚刚的知识大部分还属于那个作者，我们对知识只做到了“曾经见过”。</p>
<p><strong>我认为的输入阶段其实可以换个名字，其实就是提问阶段</strong>。学会根据知识点提出关键的问题，可以帮助我们更好的理解知识，也可以让我们不被局限在一种学习的思路下，跳出作者给我们的固定思维方式。</p>
<p>接下来我要提出一个<strong>批判性思维</strong>的概念，而且在这里我不会详述它的含义。(这个时候或许我们就可以提出<strong>“批判性思维是什么？”</strong>这个问题了，而且现在就可以<strong>跳出</strong>这篇文章，去查查这个词的意思了。不过不要忘记回来… …)</p>
<h2 id="使用批判性思维来提出问题"><a href="#使用批判性思维来提出问题" class="headerlink" title="使用批判性思维来提出问题"></a>使用批判性思维来提出问题</h2><blockquote>
<p> 还是简要说下<strong>批判性思维的三个方面</strong>：</p>
<ul>
<li>积极主动地利用关键问题的强烈愿望。</li>
<li>有一套相互关联，环环相扣的关键问题的意识。</li>
<li>恰如其分的提出和回答关键问题的能力。</li>
</ul>
</blockquote>
<p>结合批判性思维我们能够更好地提出问题，接下来我们来说下提问有哪些技巧和原则，在过程中举个栗子来加深理解。</p>
<h3 id="学会提问"><a href="#学会提问" class="headerlink" title="学会提问"></a>学会提问</h3><p>在这里总结一些我在《学会提问》一书中学到的观点，书中对如何提问有全面的讲解，现在只列举我认为在学习专业知识方面比较实用的技巧。</p>
<p>我们举个<strong>javascript面向对象</strong>学习的例子吧，接下来我们开始提问。</p>
<ul>
<li><p><strong>找线索</strong></p>
<p>学习javascript面向对象时大概率会看到这句话“JavaScript的所有数据都可以看成对象”、“一切都是对象”，接下来的知识点通常根据这句话展开。</p>
<blockquote>
<p><strong>找线索的关键</strong>：</p>
<ul>
<li>“是什么？” ：“所有数据”指的是什么？“对象”是什么？“面向对象”是什么？</li>
<li>找到结论：本例子其实就是一个结论了。我们利用“因此”、“告诉我们”等关键词判断结论，或结论一般在文章末尾位置。</li>
<li>找到理由：简单的说就是提出“为什么？”就好了。    </li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>哪些词语意思不明确</strong></p>
<p>本例子中的“一切”、“所有”、“都可以”就可以看做意思不明确的词语，我们可以提出“javascript中有哪些概念，是否都满足这个结论？有哪些数据类型，是所有的数据类型都满足这个结论吗？”。这样我们就会尝试了解或者再复习下javascript的数据类型以及相关概念有哪些。</p>
</li>
<li><p><strong>找证据</strong></p>
<p>为了证明结论的可靠性，我们需要为结论找到证据。例如，javascript中的类型满足对象的特性吗？可以像对象一样使用吗？如何使用？为什么是对象而不是其他呢？</p>
</li>
</ul>
<h2 id="提问的好处"><a href="#提问的好处" class="headerlink" title="提问的好处"></a>提问的好处</h2><p>这种提问的输入方法的优势我认为有以下几点：</p>
<ul>
<li>更有利于建立自己的知识体系。</li>
<li>学习过程也是探索的过程，不会有完成学习任务的感觉。</li>
<li>知识学习的深度完全由自己掌握，不会被学习资料所束缚。</li>
<li>更有利于知识发散和知识复习巩固。</li>
</ul>
<p>过程最后，我们把自己提出的问题找到答案，再看作者是否介绍了自己没有考虑到的知识点来进行补充。我认为把这些问题和解答进行简单的记录非常有必要。只是简单记录就好，因为我们之后还要进入<strong>输出阶段</strong>。</p>
<h1 id="回顾——输出阶段"><a href="#回顾——输出阶段" class="headerlink" title="回顾——输出阶段"></a>回顾——输出阶段</h1><p>输出阶段我们要使用的主要工具就是伟大的<a href="https://www.zhihu.com/question/20576786" target="_blank" rel="noopener">费曼学习法</a>啦，也是我曾经无意中使用的一种学习方法论。同样在这里只简单介绍费曼学习法的基本理论。</p>
<blockquote>
<p><strong>费曼技巧有四个简单的步骤</strong>：</p>
<ul>
<li><p>选择一个概念</p>
</li>
<li><p>把它教给完全不懂的另外一个人</p>
</li>
<li><p>如果卡壳，回到原始材料</p>
</li>
<li><p>回顾后简化语言表达（可选择）</p>
</li>
</ul>
</blockquote>
<p>其中第二步是重点，我们可以在模拟讲授的过程中尝试建立一个思维导图。在这个过程中，我们更容易发现自己还不熟悉或比较模糊的概念。</p>
<p>我认为费曼学习法更适用于在复习阶段。我们在对知识有一定理解的基础上，才能更好的建立场景去模拟讲授的内容。同时，在回顾知识过程中我们更容易发现哪些知识是已经遗忘了的，哪些知识是一开始就没有搞懂的。</p>
<h1 id="可调节的学习方法"><a href="#可调节的学习方法" class="headerlink" title="可调节的学习方法"></a>可调节的学习方法</h1><p>学习方法其实没有最好的只有最适合自己的，以上只是我现在正在探索的一种学习方法。为了培养将知识内化到自己知识体系的意识和提升学习效率，我会持续改进自己的学习方法。</p>
<p>当然现在的方法中还有一些模糊的规则。比如输出阶段的进行周期，现在的标准是回想一下主要知识点，如果有几个想不起来了就可以回顾一下。如果一个都想不起来了的话，那就回顾的太晚了。。。</p>
<p>另外，在这篇文章的码字过程中我用了<a href="https://zh.wikipedia.org/wiki/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95" target="_blank" rel="noopener">番茄工作法</a>，不得不说效率还是提高了点。咳咳，但是还是不能掩盖我的文章逻辑太乱的事实。。。</p>
<p>希望今后的文章能够写的越来越棒，给自己打个气(<em>^▽^</em>)</p>
]]></content>
      <categories>
        <category>自我成长</category>
      </categories>
      <tags>
        <tag>学习方法论</tag>
      </tags>
  </entry>
  <entry>
    <title>《上帝掷骰子吗：量子物理史话》读书笔记</title>
    <url>/2019/10/29/%E3%80%8A%E4%B8%8A%E5%B8%9D%E6%8E%B7%E9%AA%B0%E5%AD%90%E5%90%97%EF%BC%9A%E9%87%8F%E5%AD%90%E7%89%A9%E7%90%86%E5%8F%B2%E8%AF%9D%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>最初是因为看了李永乐老师的一期关于量子力学的视频<a href="https://www.youtube.com/watch?v=6L37Nwffy74" target="_blank" rel="noopener">薛定谔的猫与平行宇宙到底怎么回事？李永乐老师7分钟讲解量子力学</a>，觉得很有意思(我向来对这种神乎其技的事情感兴趣~)。</p>
<p>在这里插一句吼，真的墙裂推荐李永乐老师的视频，总能带我打开新世界的大门。不能fq的话，在B站上也能找到他哦~</p>
<p>咳咳，决心充实一下自己薄弱知识面的我决定仔细<del><em>装模作样</em></del>研读一下这本书，看看高大上的量子力学到底是啥东西~~</p>
<a id="more"></a>



<p><img src="https://img3.doubanio.com/view/subject/l/public/s1486674.jpg" alt=""></p>
<p>豆瓣上搜索这本书的简介，明晃晃的写着:</p>
<blockquote>
<p>“——这本书适合任何有中学基本物理概念的读者。”</p>
</blockquote>
<p>书里面经常抛出一两个公式，作者会善意的安慰你看不懂也没关系哈，不过还是有种智商被侮辱的赶脚（<del><em>毕竟我的中学物理学的稀烂</em></del>）。不过作者并没有把量子物理发展史讲的枯燥乏味，清晰的逻辑还有对不同时期的天才科学家的生活描写，让我觉得这更像一本科普类型的小说？</p>
<p>先来张天才大合照，被趣称为“集中了全人类<em>三分之一</em>的智慧”的<strong>索尔维会议</strong>。这次会议作为在量子发展史上诸多重大事件之一，成功把量子问题推到了历史最前沿。(放张图单纯是因为觉得薛定谔的颜值还是蛮高的。。。)</p>
<p><img src="http://www.dodobook.com/bookimages/shijiandexingzhuang/00044.jpg" alt=""></p>
<blockquote>
<p>印象比较深刻的是“人择原理”(anthropic principle)也叫<strong>“参与性宇宙”模型</strong>，说明了我们存在这个事实本身，决定了宇宙的某些性质为什么是这样的而不是那样的。类似于“我思故我在”。</p>
<p>一件事物的存在需要发现和提出问题的人，如果没有人来问“宇宙为什么是这样的？”，那么宇宙的种种性质也相当于不存在。</p>
<p>因此产生的逻辑循环：如果没有宇宙创造人，也不会有人发现宇宙。这种事件也叫作“自指”或者“自激活”。(想起之前看的一部电影《前目的地》，讲了一个”自己“和”自己“生下了”自己“的故事？？？)</p>
<p>我想这个观点同样可以证明死亡是人意识的湮灭，而意识才是生命的载体。</p>
</blockquote>
<p><strong><em>什么是意识？</em></strong></p>
<p>书中对意识的解释，类比了什么是信息。一个消息是一种信息，但是，它的载体本身并非信息，它所蕴涵的内容才是。同样一条信息，可以通过不同载体表达出来。</p>
<p>我们的意识组成脑的原子群的一种“组合模式”，正因为有了意识，我们的脑才和“石头”有了区别。我们的意识是完全建立在我们的脑的结构模式之上的。</p>
<p>如果复制我们的意识，那么这个“复制人”是否就是本人呢？比如我们复印一份文件，能不能说新的这份文件和原版的是同样一份文件呢？</p>
<p><strong><em>图灵实验</em></strong></p>
<p>之前看的一部《机械姬》，讲了一个老板找来公司的一个程序员来给自己创造的机器人做图灵实验，结果两人都被机器人反杀的故事(有些后怕，程序员安心搬砖不好的吗？)。</p>
<p>”图灵实验“是一种判定计算机能否像人那般“思考”的标准。如果计算机能够使人感受不到计算机与真人的区别，那么就可以判定计算机和人一样具备思考的能力。</p>
<p>如果把意识看做一种模式的话，我认为这种模式肯定是可以创造和可复制的。例如《盗梦空间》中尝试在大脑中植入一个想法，这个想法如果是一段意识信息的话，那么这样的尝试就是有可能的。</p>
<blockquote>
<p>一个有意思的悖论：</p>
<p>一粒沙落地不算一个沙堆，两粒沙落地不算一个沙堆，但十万粒沙落地肯定是一个沙堆了。那么，具体到哪一粒沙落地时才形成一个沙堆呢？</p>
<p>确实想到头痛。。。吃一口汉堡可能还不会变胖，但到底吃到第几口我会长胖呢？到那口我就不吃了。。。</p>
<p>生气的是，科学家不屑于研究这种模糊性的问题。。。这让世界上此时又多了一个胖子。</p>
</blockquote>
<p>有空还是要重新刷一下这本书比较好，好多理论都忘记了。不光作为一本科普读物，思考一些人生哲理也不错？？</p>
<p>希望下次更新学习相关的读书笔记，看起来没那么不务正业。</p>
<p>额，还是先修复我的评论系统再说吧？！</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>了解CSS原生变量</title>
    <url>/2019/10/28/CSS%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>最近在做项目换肤功能的过程中，早在项目初期了解的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties" target="_blank" rel="noopener">CSS变量</a>终于派上了用场，不得不感叹这真是有意义的发明。本文将总结一下CSS变量的原理与使用方法。</p>
<h1 id="CSS变量简介"><a href="#CSS变量简介" class="headerlink" title="CSS变量简介"></a>CSS变量简介</h1><blockquote>
<p><strong>CSS变量</strong>（CSS Variable）又叫 <strong>CSS 自定义属性</strong>（CSS Custom Properties)，顾名思义有着与变量相同的特点。程序设计中的<strong>变量</strong>是可以在一段程序中重复使用，同时可以重复赋值的值(当然，是在不考虑变量作用域的情况下)。</p>
</blockquote>
<p>那么CSS变量也就具有重复使用和重新赋值的特性咯，那就把它当成你理解的变量就好了。</p>
<p><a href="https://caniuse.com/#feat=css-variables" target="_blank" rel="noopener">CSS变量的兼容性</a>，目前Chrome 49、Firefox 42、Safari 9.1和iOS Safari 9.3以上都支持CSS变量。</p>
<a id="more"></a>



<h2 id="CSS变量的使用"><a href="#CSS变量的使用" class="headerlink" title="CSS变量的使用"></a>CSS变量的使用</h2><p>如同变量的使用“一样”，我们首先需要<strong>定义</strong>一个CSS变量，变量名称统一使用<code>--</code>开头：</p>
<p><strong><em>CSS变量区分大小写</em></strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">--color</span>: <span class="selector-tag">red</span>;</span><br><span class="line"><span class="selector-tag">--COLOR</span>: <span class="selector-tag">red</span>;</span><br><span class="line"><span class="comment">/*CSS变量对大小写敏感，--color 和 --COLOR 是两个不同的变量*/</span></span><br></pre></td></tr></table></figure>

<p>这样我们可以定义一个属性值为<code>red</code>的变量<code>--color</code>，在想要将颜色设为red的地方我们这样来使用：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--color);        <span class="comment">/*var()将变量--color解析成属性值，赋值给相应的属性*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><em>无效的变量定义</em></strong></p>
<p>声明无意义的变量值，通过<code>var()</code>函数调用后会被解析为初始值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--color</span>: <span class="number">20px</span>;                   <span class="comment">/*无效的定义*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">var</span>(--color);  <span class="comment">/* background-color将回退为初始值transparent */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><em>使用var()函数时，可以发送第二个参数</em></strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: <span class="selector-tag">var</span>(<span class="selector-tag">--custom-width</span>, 33%);<span class="comment">/*var()可以接受两个参数，没有找到定义的属性会使用第二个参数值*/</span></span><br></pre></td></tr></table></figure>



<p><strong><em>可以直接在HTML中使用CSS变量</em></strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--HTML--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">style</span>=<span class="string">"--color: red;"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">span &#123;</span><br><span class="line">  color: var(--color); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><em>可以在其他CSS变量中使用CSS变量</em></strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">--base-red-color</span>: <span class="selector-id">#f00</span>;</span><br><span class="line"><span class="selector-tag">--background-gradient</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">top</span>, <span class="selector-tag">var</span>(<span class="selector-tag">--base-red-color</span>), <span class="selector-id">#222</span>);</span><br><span class="line"><span class="comment">/*linear-gradient用于创建一个表示两种或多种颜色线性渐变的图片*/</span></span><br></pre></td></tr></table></figure>



<p><strong><em>在媒体查询中使用</em></strong></p>
<blockquote>
<p>注：在媒体查询不能直接修改在媒体查询作用域外的变量哦，必须在<code>:root</code>重新定义~</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">	<span class="attribute">--padding</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">--color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在屏幕宽度大于750px以上设备使用*/</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">750px</span>) &#123;</span><br><span class="line">	<span class="comment">/*--padding: 30px; */</span>    <span class="comment">/*错误的使用*/</span>          </span><br><span class="line">    </span><br><span class="line">    <span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">        <span class="attribute">--padding</span>: <span class="number">30px</span>;    <span class="comment">/*正确的使用*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-tag">div</span>&#123;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="built_in">var</span>(--color);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><em>支持使用calc()函数计算</em></strong></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/calc" target="_blank" rel="noopener">calc()</a>可以在声明CSS属性时使用，返回参数表达式的计算结果</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">--text-input-width</span>: 5000<span class="selector-tag">px</span>;</span><br><span class="line">max-width: calc(var(--text-input-width) / 2);  /*max-width被设置为2500px*/</span><br></pre></td></tr></table></figure>



<h2 id="全局变量、局部变量、变量继承"><a href="#全局变量、局部变量、变量继承" class="headerlink" title="全局变量、局部变量、变量继承"></a>全局变量、局部变量、变量继承</h2><p>既然有变量的特性，那么也可以声明全局变量和局部变量。所有全局变量的声明都要在<code>:root</code>下，它代表文档的根元素，这样的变量可以在全局使用。此外，在其他地方定义的变量就都是局部变量。</p>
<p>局部变量只能够在被声明的元素及其子元素中使用。局部变量会覆盖全局变量的属性值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">    <span class="attribute">--color</span>: red;           <span class="comment">/*全局变量*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="attribute">--color</span>: green;         <span class="comment">/*局部变量*/</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--color);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当前文档中的span文本都是绿色，而其他文本都是红色*/</span></span><br></pre></td></tr></table></figure>

<p>与其他CSS属性一样，CSS中的变量也是可以继承的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">  <span class="attribute">--color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">P</span> &#123;</span><br><span class="line">  <span class="attribute">--pColor</span>: green;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--color);    <span class="comment">/*red*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &gt; <span class="selector-tag">span</span>&#123;</span><br><span class="line">  <span class="attribute">color </span>: <span class="built_in">var</span>(-pColor);  <span class="comment">/*使用父定义的变量属性值 green*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用CSS变量修改html元素样式属性"><a href="#使用CSS变量修改html元素样式属性" class="headerlink" title="使用CSS变量修改html元素样式属性"></a>使用CSS变量修改html元素样式属性</h2><p>刚刚提到了CSS变量又叫做CSS自定义属性，那么对CSS属性的操作能否在CSS变量上生效呢？</p>
<p>我们来修改文档对象<code>--color</code>变量的属性值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.style.setProperty(<span class="string">'--color'</span>, <span class="string">'black'</span>);</span><br></pre></td></tr></table></figure>

<p>这样会向当前根元素中添加一条行内样式属性，进而改变当前页面使用<code>--color</code>值的属性<strong>(在根元素的属性值会覆盖css中定义的属性值)</strong>：</p>
<p><img src="https://github.com/cheerforever/MarkDownPhotos/blob/master/CSSVariable_pic1.png?raw=true" alt="行内样式"></p>
<p>也可以使用js修改元素的属性使用CSS变量定义的属性值(前提是包含CSS变量的定义)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.style.setProperty(<span class="string">'color'</span>, <span class="string">'var(--color)'</span>); </span><br><span class="line"><span class="comment">//保证--color变量已经定义过</span></span><br></pre></td></tr></table></figure>



<h1 id="CSS变量与CSS预处理器"><a href="#CSS变量与CSS预处理器" class="headerlink" title="CSS变量与CSS预处理器"></a>CSS变量与CSS预处理器</h1><p>原生CSS的使用存在着一些痛点：</p>
<ul>
<li><p>语法不够强大，在模块化开发中有许多重复的选择器和属性值。</p>
</li>
<li><p>没有合理的样式复用机制，样式的维护和修改通常比较困难。</p>
</li>
</ul>
<p>因此，我们需要一种提供 CSS样式的复用机制、减少冗余代码、提高样式代码可维护性的工具。<strong>CSS预处理器</strong>的诞生解决了这个问题。</p>
<p><strong>CSS预处理器</strong>将css变成了可编译，可赋变量的形式，我们可以使用预处理器提供的语法生成CSS。<a href="http://sass.bootcss.com/" target="_blank" rel="noopener">Sass</a>是CSS 预处理器的一种，<a href="http://lesscss.org/" target="_blank" rel="noopener">Less</a>和<a href="http://stylus-lang.com/" target="_blank" rel="noopener">Stylus</a>也是比较流行的CSS预处理器。</p>
<h2 id="Sass、Less和Stylus"><a href="#Sass、Less和Stylus" class="headerlink" title="Sass、Less和Stylus"></a>Sass、Less和Stylus</h2><p>三种CSS预处理器的主要区别：</p>
<p><img src="https://github.com/cheerforever/MarkDownPhotos/blob/master/Untitled_Diagram.png?raw=true" alt="区别说明"></p>
<h2 id="CSS变量与CSS预处理器的主要区别"><a href="#CSS变量与CSS预处理器的主要区别" class="headerlink" title="CSS变量与CSS预处理器的主要区别"></a>CSS变量与CSS预处理器的主要区别</h2><p>上文提到的CSS预处理能做到的对CSS的改进优化，CSS变量也同样可以做到。</p>
<p>此外它还有一些优势：</p>
<ul>
<li><p>CSS 变量实际上是 DOM 的一部分，可以访问DOM。例如上文给出的使用JavaScript方法和CSS变量改变DOM样式的例子。</p>
</li>
<li><p>它不需要经过任何转译步骤，不需要任何设置就能直接使用，因为它是浏览器原生支持的。</p>
</li>
<li><p>CSS预处理器中变量的作用域是静态的，而CSS变量的作用域是动态的。</p>
</li>
</ul>
<blockquote>
<p>对于CSS预处理器的变量，虽然我们可以在编译过程中改变一个变量的值，但是当它被编译成CSS以后就        是静态的了。而CSS变量则可以响应上下文的变化，我们可以灵活地在媒体查询、各种CSS选择器或者使用JavaScript来修改CSS变量的值，做到在某个作用域下使用修改后的CSS变量属性值。</p>
</blockquote>
<p>更多关于Sass预处理器的内容，将会在后续补充。。。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://zhuanlan.zhihu.com/p/27474707" target="_blank" rel="noopener">【译】CSS变量的正确使用方法</a></p>
<p><a href="https://codeburst.io/css-variables-explained-with-5-examples-84adaffaa5bd" target="_blank" rel="noopener">CSS Variables explained with 5 examples</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
